Его можно использовать, и он означает отдельный скоуп для всех переменных, объявленных в нём (возможен и "захват переменных" объявленных вне скоупа ранее, естественно).

```go
var i, s1 = 1, "foo"

{
    var j, s2 = 2, "bar"

    println(i, s1) // 1 foo
    println(j, s2) // 2 bar

    s1 = "baz"
}

println(i, s1) // 1 baz
//println(j, s2) // ERROR: undefined: j and s2
```

Так же это может быть связано с AST (Abstract Syntax Tree) — когда оно строится и происходят SSA (Static Single Assignment) оптимизации, к сожалению SSA не работает на всю длину дерева. Как следствие, если у нас слишком длинная функция (примерно дохулион строк) и мы по каким-то причинам не можем её декомпозировать, но можем изолировать какие-то скоупы то, таким образом, мы помогаем SSA произвести оптимизации (если они возможны).