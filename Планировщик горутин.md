[Goroutine scheduler](https://github.com/golang/go/blob/f296b7a6f045325a230f77e9bda1470b1270f817/src/runtime/proc.go#L19) является перехватывающим задачи (work-stealing) планировщиком, который был введен еще в Go 1.1 Дмитрием Вьюковым вместе с командой Go. Основная его суть заключается в том, что он управляет:
- [`G` (**горутинами**)](https://github.com/golang/go/blob/f296b7a6f045325a230f77e9bda1470b1270f817/src/runtime/runtime2.go#L395) — просто горутины Go
- [`M` (машинами aka **потоками** или **тредами**)](https://github.com/golang/go/blob/f296b7a6f045325a230f77e9bda1470b1270f817/src/runtime/runtime2.go#L473) — потоки ОС, которые могут выполнять что-либо или же бездействовать
- [`P` (**процессорами**)](https://github.com/golang/go/blob/f296b7a6f045325a230f77e9bda1470b1270f817/src/runtime/runtime2.go#L552) — можно рассматривать как ЦП (физическое ядро); представляет ресурсы, необходимые для выполнения нашего Go кода, такие как планировщик или состояние распределителя памяти

**Основная задача планировщика** состоит в том, чтобы сопоставить каждую `G` (код, который мы хотим выполнить) с `M` (где его выполнять) и `P` (права и ресурсы для выполнения).

Когда `M` (поток ОС) прекращает выполнение нашего кода, он возвращает свой `P` (ЦП) в пул свободных `P`. Чтобы возобновить выполнение Go кода, он должен повторно заполучить его. Точно так же, когда горутина завершается, объект `G` (горутина) возвращается в пул свободных `G` и позже может быть повторно использован для какой-либо другой горутины.

Go запускает столько тредов, сколько доступно процессорных ядер (если вы специально это не перенастраиваете) и распределяет на эти треды сколько угодно горутин которые уже запускает программист. В один момент на одном ядре ЦП может находиться в исполнении только одна грутина, а в очереди исполнения их может быть неограниченное количество.

Треды `M` во время выполнения могут переходить от одного процессора `P` к другому. Например, когда тред делает системный вызов, в ответ на который ОС блокирует этот тред (например — чтение какого-то большого файла с диска) — мало того что заблокируется сама горутина, что спровоцировала этот вызов, но и все остальные, что стоят в очереди для этого процессора `P`. Чтоб этого не происходило — Go отвязывает горутины стоящие в очереди от этого процессора `P` и переназначает на другие.

Основные типы многозадачности что используются в большинстве ОС это "вытесняющая" (все ресурсы делятся между всеми программами одинаково, всем выделяется одинаковое время выполнения) и "кооперативная" (программы выполняются столько, сколько им нужно, и сами уступают друг-другу место). В Go используется **неявная кооперативность**:
- Горутина уступает место другим при обращении к вводу-выводу, каналам, вызовам ОС и т.д.
- Может уступить место при вызове любой функции (с некоторой вероятностью произойдет переключение между горутинами)
- Есть явный способ переключить планировщик на другую горутину — вызвать функцию `runtime.Gosched()` (почти никогда не нужна, но она есть)

Основные принципы планировщика:
- Очередь FIFO (first in — first out) — порядок запуска горутин обуславливается порядом их вызова
- Необходимый минимум тредов — создается не больше тредов чем доступных ядер ЦП
- Захват чужой работы — когда тред простаивает, то он не удаляется рантаймом Go, а будет по возможности "нагружен" работой, взятой из очередей горутин на исполнение с других тредов
- "Неинвазивность" — работа горутин насильно не прерывается

Ограничения:
- Очередь FIFO (нет приоритезации и изменения порядка исполнения)
- Отсутствие гарантий времени выполнения (времени запуска горутин)
- Горутины могут перемещаться между тредами, что снижает эффективность кэшей