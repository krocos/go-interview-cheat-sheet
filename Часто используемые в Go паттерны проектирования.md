# Порождающие паттерны
- **Singleton**
  Обеспечивает создание только одного экземпляра класса и предоставляет к нему глобальную точку доступа. Это полезно, когда нужен единственный экземпляр ресурса, например, для подключения к базе данных. 
- **Factory (Фабрика)**
  Предоставляет интерфейс для создания объектов, позволяя подклассам изменять тип создаваемых объектов. Это полезно, когда нужно создать объект, но не хочется привязываться к конкретному классу. 
- **Builder (Строитель)**
  Позволяет создавать сложные объекты пошагово, что особенно полезно при конструировании объектов с множеством параметров. 
- **Function-Options (функциональные опции)**
  Позволяет передавать опции для новых объектов в виде функций.
# Структурные паттерны
- **Decorator (Декоратор)**
  Динамически добавляет объектам новую функциональность, оборачивая их в обёртки. Например, можно добавить логирование к функции, обернув её в декоратор. 
- **Facade (Фасад)**
  Предоставляет простой интерфейс к сложной системе классов. Это упрощает использование сложной логики, скрывая ее от пользователя. 
- **Adapter (Адаптер**
  Позволяет объектам с несовместимыми интерфейсами работать вместе. Это полезно, когда нужно использовать старую библиотеку с новым кодом. 
# Поведенческие паттерны
- **Strategy (Стратегия)**
  Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми. Это позволяет выбирать алгоритм во время выполнения программы. 
- **Observer (Наблюдатель)**
  Один объект (наблюдатель) подписывается на события другого объекта (субъекта) для получения уведомлений об изменениях состояния. Например, система уведомлений в чате. 
- **State (Состояние)**
  Позволяет объекту изменять своё поведение в зависимости от своего состояния.Это полезно, когда объект должен вести себя по-разному в зависимости от своего внутреннего состояния. 
# Паттерны для работы с многопоточностью
- **Future/Promise**
  Асинхронное выполнение задачи, не блокирующее основной поток.
- **Generator**
  Создание потока данных с помощью горутины.
- **Pipeline**
  Разделение задачи на этапы обработки данных.
- **Fan-in/Fan-out**
  Распараллеливание и сбор результатов.
- **Worker Pool**
  Управление пулом горутин для обработки задач.
- **Semaphore**
  Контроль числа одновременно выполняемых горутин.
- **Обработка ошибок в горутинах**
  Безопасная обработка ошибок, возникающих в горутинах.