Основнаая статья: [Go Concurrency Patterns: Pipelines and cancellation](https://go.dev/blog/pipelines)

Конкурентные примитивы и часто используемые подходы в Go упрощают создание потоковых конвейеров данных, которые эффективно используют ввод-вывод и несколько процессоров, а так же упрощают разработку.
# Функция, которая возвращает канал
```go
func boring(msg string) <-chan string { // Returns receive-only channel of strings.**
    c := make(chan string)
    go func() { // We launch the goroutine from inside the function.
        for i := 0; ; i++ {
            c <- fmt.Sprintf("%s %d", msg, i)
            time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond)
        }
    }()
    return c // Return the channel to the caller.
}
```
# Пайпалйн
В Go нет формального определения пайплайна; это всего лишь один из многих видов параллельных программ. Неформально пайплайн - это серия этапов, соединенных [[Каналы|каналами]], где каждый этап представляет собой группу [[Горутины|горутин]], выполняющих одну и ту же функцию. На каждой стадии [[Горутины|горутины]]:
- Получают входные данные через входящие каналы
- Производят в этими данными какие-то операции, например, производят новые данные
- Отправляют выходные данные в выходные каналы

Каждая стадия может иметь любое количество входных и выходных каналов, но первая и последняя могут иметь только выходящие и входящие каналы соответственно. Певыю стадию обычно называют источник (*source*) или провайдер (*provider*), а последнюю слив (*sink*) или потребитель (*consumer*).

Ещё:
> Goroutines are not garbage collected; they must exit on their own.

Поэтому горутины должны выходить самостоятельно.

Гайд по построению пайплайна:
- Этапы закрывают свои исходящие каналы, когда все операции отправки завершены
- Этапы продолжают получать значения из входящих каналов до тех пор, пока эти каналы не будут закрыты или отправители не будут разблокированы

Гайд по остановке пайплайна:
- Этапы закрывают свои исходящие каналы, когда все операции отправки завершены
- Этапы продолжают получать значения от входящих каналов до тех пор, пока эти каналы не будут закрыты

Для остановки лучше использовать **context**.
Для одиночного broadcast сигнала (например done канал) можно использовать **`close(done)`**.
# FunIn and FunOut
- **FunIn** – это когда мы из нескольких каналов одного типа собираем один канал этого типа. Перенаправляем сообщения с нескольких каналов в один.
- **FunOut** – это когда мы начинаем читать данные, поступающие из входящего канала в нескольких горутинах, для которых этот канал становится входящим. Таким образом мы можем **контроллировать параллеллизм**.
# Продвинутые паттерны
## Паника выводит стек
Каждая горутина имеет свой стек (память на стеке).
Когда при разработке или тестировании надо получить весь стек программы, то можно вызвать панику и получить все стеки вызовов.
```go
panic("show me the stacks")
```
## Петля событий
Или `for-select` loop.
Не обязательно в `for-select` слушать один входной канал или контекст на отмену, отправлять в выходной или канал ошибок.
Можно слушать много разных входящих каналов или отправлять в несколько разных outbound каналов. А так же включать/выключать кейсы.
## Канал каналов
Или `service channel`, или `reply channels`.
Через канал можно передать канал, что бы принимающая горутина могла в него записать всё что нужно.
```go
type sub struct {
    closing chan chan error
}
```

```go
func (s *sub) Close() error {
    errc := make(chan error)
    s.closing <- errc
    return <-errc
}
```

```go
var err error // set when Fetch fails
for {
	select {
	case errc := <-s.closing:
		errc <- err
		close(s.updates) // tells receiver we're done
		return
	}
}
```
### Сообщения содержащие канал
Частный случай.
Этим, например, можно контролировать *последовательность* получения данных.
```go
type Message struct {
    str string
    wait chan bool
}
```
А потом
```go
waitForIt := make(chan bool) // Shared between all messages.
```
И отправляем
```go
c <- Message{ fmt.Sprintf("%s: %d", msg, i), waitForIt }
<-waitForIt
```
## select и nil-каналы
Селект блокируется на nil каналах.
И
Селект никогда не выбирает блокированные кейсы.

Можно сделать вывод, что в долгом for-select можно включать/выключать кейсы. Или активировать канал по условию, а select кейсы останутся без изменений.

Простой пример:
```go
func main() {
    a, b := make(chan string), make(chan string)
    go func() { a <- "a" }()
    go func() { b <- "b" }()
    if rand.Intn(2) == 0 {
        a = nil
        fmt.Println("nil a")
    } else {
        b = nil
        fmt.Println("nil b")
    }
    select {
    case s := <-a:
        fmt.Println("got", s)
    case s := <-b:
        fmt.Println("got", s)
    }
}
```

Пример с активацией канала по условию:
```go
var pending []Item // appended by fetch; consumed by send
for {
	var first Item
	var updates chan Item
	if len(pending) > 0 {
		first = pending[0]
		updates = s.updates // enable send case
	}
	select {
	case updates <- first:
		pending = pending[1:]
	}
}
```
