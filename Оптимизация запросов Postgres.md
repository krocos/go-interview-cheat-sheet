Оптимизация запросов в PostgreSQL — важная задача для повышения производительности базы данных. Вот ключевые аспекты, которые нужно знать:  
# Анализ запросов и их производительности  
- **`EXPLAIN` и `EXPLAIN ANALYZE`** – основные инструменты для анализа плана выполнения запроса.  
  - `EXPLAIN` показывает предполагаемый план.  
  - `EXPLAIN ANALYZE` выполняет запрос и показывает реальные метрики (время, количество строк).  
- **`pg_stat_statements`** – расширение для отслеживания статистики выполнения запросов (частые, медленные запросы).  
```sql
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@example.com';
```
# Индексы  
- **[[Типы индексов]] и их применение**:  
	- **B-tree** – стандартный индекс для равенства и диапазонов (`=`, `>`, `<`, `LIKE 'prefix%'`).  
	- **Hash** – только для равенства (`=`), быстрее B-tree, но не поддерживает сортировку.  
	- **GIN** – для составных данных (JSONB, массивы, полнотекстовый поиск).  
	- **GiST/SP-GiST** – для геоданных, полнотекстового поиска.  
	- **BRIN** – для больших таблиц с упорядоченными данными (логи, временные ряды).  

- **Оптимизация индексов**:  
	- Индексируйте часто используемые столбцы в `WHERE`, `JOIN`, `ORDER BY`.  
	- Используйте **частичные индексы**, если данные фильтруются (`CREATE INDEX ... WHERE condition`).  
	- **Составные индексы** (мультиколоночные) эффективны, если запросы используют несколько полей.  

```sql
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_orders_user_status ON orders(user_id, status) WHERE status = 'pending';
```
# Оптимизация самих запросов  
- **Избегайте `SELECT *`** – выбирайте только нужные столбцы.  
- **Используйте `LIMIT`** для ограничения выборки.  
- **Оптимизируйте `JOIN`** – уменьшайте размер таблиц перед соединением.  
- **Избегайте `NOT IN`** – лучше `LEFT JOIN ... WHERE ... IS NULL`.  
- **`UNION ALL` быстрее `UNION`** (если дубликаты не нужны).  
- **Кэшируйте результаты** сложных вычислений (например, через материализованные представления).  

```sql
-- Плохо
SELECT * FROM orders WHERE user_id NOT IN (SELECT id FROM banned_users);

-- Лучше
SELECT o.* FROM orders o 
LEFT JOIN banned_users bu ON o.user_id = bu.id 
WHERE bu.id IS NULL;
```
# Настройка PostgreSQL  
- **`work_mem`** – память для операций сортировки и хеширования (увеличивайте для сложных запросов).  
- **`shared_buffers`** – кэш PostgreSQL (обычно 25% от RAM).  
- **`effective_cache_size`** – оценка доступного кэша ОС для планировщика.  
- **`maintenance_work_mem`** – память для обслуживания (создание индексов, VACUUM).  

```sql
ALTER SYSTEM SET work_mem = '64MB';
ALTER SYSTEM SET shared_buffers = '4GB';
```
# Обслуживание БД  
- **`VACUUM` и `ANALYZE`** – очистка "мертвых" строк и обновление статистики.  
- **Автовакуум (`autovacuum`)** должен быть включен.  
- **Перестройка индексов** (`REINDEX`) при их фрагментации.  

```sql
VACUUM ANALYZE users;
REINDEX TABLE users;
```
# Дополнительные методы  
- **Партиционирование** – разделение больших таблиц на части (по дате, диапазонам).  
- **Материализованные представления** (`MATERIALIZED VIEW`) – кэширование результатов.  
- **Оптимизация схемы**: нормализация/денормализация в зависимости от нагрузки.  
- **Использование соединений (Connection Pooling)** – например, PgBouncer для снижения накладных расходов.  
# Мониторинг и профилирование  
- **Логи медленных запросов** (`log_min_duration_statement`).  
- **`pg_stat_activity`** – текущие запросы и блокировки.  
- **`pgBadger`** – анализ логов PostgreSQL.  
# Вывод  
Оптимизация запросов в PostgreSQL включает:  
1. Анализ через `EXPLAIN`.  
2. Правильные индексы.  
3. Оптимизацию SQL-запросов.  
4. Настройку параметров сервера.  
5. Регулярное обслуживание БД.  

Лучший подход – итеративный: находите узкие места, тестируйте изменения, измеря результат.