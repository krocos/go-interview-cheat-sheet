Garbage Collection — это процесс освобождения места в памяти, которая больше не используется. [[Стек]] освобождается быстро и просто (условно-самостоятельно), а вот с [[Куча|кучей]] сложнее.

В основе работы GC в Go лежит:
- "Трехцветный алгоритм пометки и очистки" (выполняется параллельно с основной программой) — все данные в [[Куча|куче]] представляются в виде связанного графа, каждая вершина которого (каждый объект, данные) может быть помечена как "белая", "серая", или "чёрная"; данный граф обходится в несколько проходов, все вершины размечаются своими цветами, и "белые" (мусорные) объекты могут быть удалены ("чёрные" — точно нельзя удалять; "серые" — под вопросом, пока не трогать)
- Write Barrier, следящий за тем, чтоб черные объекты не указывали на белые; и "останавка мира" (Stop The World, STW) для включения или отключения Write Barrier

GC можно вызвать ручками — `runtime.GC()`, но пользоваться этим нужно с осторожностью (есть риск блокировки вызывающей стороны или всего приложения целиком).

По умолчанию, **GC запускается самостоятельно когда размер кучи становится в 2 раза больше** (за это отвечает `Pacer`; данный коэффициент можно регулировать при сборке с помощью env `GOGC`).
# Основные фазы работы GC
## Mark (Маркировка)
- **Mark Setup**: Остановка всех горутин (STW - Stop The World) для подготовки к маркировке
- **Concurrent Marking**: Параллельная маркировка используемых объектов (без остановки программы)
- **Mark Termination**: Короткая пауза (STW) для завершения маркировки
## Sweep (Очистка)
- Освобождение памяти, занятой немаркированными (неиспользуемыми) объектами
- Выполняется параллельно с работой программы
## Scavenge (Освобождение)
- Возвращение свободной памяти операционной системе (опционально)
# Детали работы
- GC в Go **не generational** (не использует поколения объектов как в Java)
- Использует **триколорную маркировку** (tri-color marking)
- Работает **параллельно** с основной программой (кроме коротких STW пауз)
- **Адаптивный** - подстраивается под нагрузку и размер кучи
# Недостатки:
- Не реализован алгоритм поколений (GC Generations)
- Не реализовано уплотнение
- Stop the World (STW), вызываемый аж дважды
- Нет возможности тонкой настройки
# Оптимизация
- Уменьшить частоту вызова GC с помощью `GOGC`
- Использовать балласт (выделять большое количество памяти при запуске приложения `make([]byte, 10 << 30) // 10 GiB`), который увеличивает базовый размер кучи, не будет выделен как мусор, помечается за `O(1)`, и выделяется в виртуальном пространстве не используя физическую память
- Использовать `sync.Pool` (он хорошо дружит с GC)

Что такое [[Escape analysis|escape analysis]].