Необходимы для абстракции поведения от реализаций.
# Duck-typing

> Если это выглядит как утка, плавает как утка и крякает как утка, то это, вероятно, утка и есть.

Если тип содержит в себе все методы, что объявлены в интерфейсе и их сигнатуры совпадают — она автоматически удовлетворяет интерфейс.

Нужны для полиморфизма. Полиморфизм — способность функции обрабатывать данные разных типов. Достаточно, чтобы все объекты поддерживали необходимый набор методов.

# Интерфейсный тип

Интрефейсный тип выглядит примерно так:
```go
type iface struct {
    tab  *itab
    data unsafe.Pointer
}
```
`tab` — это указатель на *Interface Table* или `itable` — структуру, которая хранит некоторые метаданные о типе и список методов, используемых для удовлетворения интерфейса, а `data` указывает на реальную область памяти, в которой лежат данные изначального объекта (статическим типом).

Компилятор генерирует метаданные для каждого статического типа, в которых, помимо прочего, хранится список методов, реализованных для данного типа.
Аналогично генерируются метаданные со списком методов для каждого интерфейса.
Теперь, во время исполнения программы, *runtime Go* может вычислить `itable` на лету (*late binding*) для каждой конкретной пары. Этот `itable` кешируется, поэтому просчёт происходит только один раз.

Зная это, становится очевидно, почему Go ловит несоответствия типов на этапе компиляции, но кастинг к интерфейсу – во время исполнения.
# Nil interface
Что бы интерфейс был `nil` надо что бы `tab` и `data` были `nil`.
Поэтому если интерфейсу присвоить неинициализированный указатель на что-то, то интерфейс уже не будет `nil`, хотя данные == `nil`.
# Пустой interface
Ему удовлетворяют вообще любые типы.
Использовать стоит в крайних случаях.
# Где описывать интерфейсы?
Описывают обычно там где используют. Реализовать можно потом где угодно.
# Проверка типа
Вот тут можно прочитать про [[type switch]].