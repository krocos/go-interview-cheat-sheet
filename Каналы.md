Есть синхронные (**небуферизированные**) и асинхронные (**буферизированные**) каналы, оба работают по принципу FIFO очереди.

> Don't communicate by sharing memory; share memory by communicating.

Канал — это объект связи, с помощью которого (чаще всего) [[Горутины|горутины]] обмениваются данными. Для создания каналов есть ключевое слово `chan` и синтаксис со стрелкой для чтения или записи в него.

**Запись** данных в закрытый канал **вызовет панику**.

Чтение или запись данных в **небуферизированный** канал блокирует горутину и контроль передается свободной горутине.

Проверка открыт ли канал получается через вторую переменную при чтении канала. Если она == false, то канал закрыт, а значение будет zero-value.

**Буферизированный канал** создается указанием второго аргумента для `make`. Такой канал не блокируется до тех пор, пока буфер не будет заполнен.
Подобно слайсам, буферизированный канал имеет длину (`len`, количество сообщений в очереди, не считанных) и емкость (`cap`, размер самого буфера канала).
Используя буферизованный канал и цикл `for val := range c { ... }` мы можем читать с **закрытых** каналов (поскольку у закрытых каналов данные все еще живут в буфере).

Так же каналы бывают **однонаправленные**. Это можно указать при создании канала через `make` или в сигнатуре функции/метода.
# Чтение
Читать "одновременно" из нескольких каналов возможно с помощью `select` (оператор `select` является блокирующим за исключением использования `default`).

В случае, если в оба канала одновременно придут сообщения (или они уже там были), то `case` будет выбран **случайно** (а не по порядку их объявления).

Если ни один из каналов недоступен для взаимодействия, и секция `default` отсутствует, то текущая горутина переходит в состояние `waiting` до тех пор, пока какой-то из каналов не станет доступен.
# Устройство
```go
type hchan struct {
    qcount   uint           // количество элементов в буфере
    dataqsiz uint           // размерность буфера
    buf      unsafe.Pointer // указатель на буфер для элементов канала
    elemsize uint16         // размер одного элемента в канале
    closed   uint32         // флаг, указывающий, закрыт канал или нет
    elemtype *_type         // содержит указатель на тип данных в канале
    sendx    uint           // индекс (смещение) в буфере по которому должна производиться запись
    recvx    uint           // индекс (смещение) в буфере по которому должно производиться чтение
    recvq    waitq          // указатель на связанный список горутин, ожидающих чтения из канала
    sendq    waitq          // указатель на связанный список горутин, ожидающих запись в канал
    lock     mutex          // мьютекс для безопасного доступа к каналу
}
```
В общем случае, горутина захватывает мьютекс, когда совершает какое-либо действие с каналом, кроме случаев lock-free проверок при неблокирующих вызовах.

Go не выделяет буфер для синхронных (небуферизированных) каналов, поэтому указатель на буфер равен `nil` и `dataqsiz` равен нулю. При чтении из канала горутина произведёт некоторые проверки, такие как: закрыт ли канал, буферизирован он или нет, содержат ли гоуртины в send-очереди. Если ожидающих отправки горутин нет — горутина добавит сама себя в `recvq` и заблокируется. При записи другой горутиной все проверки повторяются снова, и когда она проверяет `recvq` очередь, она находит ожидающую чтение горутину, удаляет её из очереди, записывает данные в её стек и снимает блокировку. Это единственное место во всём рантайме Go, когда одна горутина пишет напрямую в стек другой горутины.

При создании асинхронного (буферизированного) канала `make(chan bool, 1)` Go выделяет буфер и устанавливает значение `dataqsiz` в единицу. Чтобы горутине отправить значение в канал, сперва производятся несколько проверок: пуста ли очередь `recvq`, пуст ли буфер, достаточно ли места в буфере. Если всё ок, то она просто записывает элемент в буфер, увеличивает значение `qcount` и продолжает исполнение далее. Когда буфер полон, буферизированный канал будет вести себя точно так же, как синхронный (небуферизированный), тоесть горутина добавит себя в очередь ожидания и заблокируется.

Проверки буфера и очереди реализованы как атомарные операции, и не требуют блокировки мьютекса.

При **закрытии** канала Go проходит по всем ожидающим на чтение или запись горутинам и разблокирует их. Все получатели получают дефолтные значение переменных того типа данных канала, а все отправители паникуют.