Компиляция — это процесс преобразования вашего (говно)кода в машинный код. Первое понятно тебе, второе — машине.
# Этапы компиляции
`cmd/compile` содержит основные пакеты Go компилятора. Процесс компиляции может быть логически разделен на четыре фазы:
- **Parsing** (`cmd/compile/internal/syntax`) — сорец парсится, разбивается на токены, создается синтаксическое дерево
- **Type-checking and AST (Abstract Syntax Tree) transformations** (`cmd/compile/internal/gc`) — дерево переводится в AST, тут же происходит магия по авто-типизации, проверок интерфейсов этапа компиляции, определяется мертвый код и происходит escape-анализ
- **Generic SSA (Static Single Assignment)** (`cmd/compile/internal/gc`, `cmd/compile/internal/ssa`) — AST переводится в SSA (промежуточное представление более низкого уровня), что упрощает реализацию оптимизаций; так же применяются множественные оптимизации этого уровня (тут, например, циклы `range` переписываются в обычные `for`; а `copy` заменяется перемещением памяти), удаляются ненужные проверки на `nil` и т.д.
- **Generating machine code** (`cmd/compile/internal/ssa`, `cmd/internal/obj`) — универсальные штуки перезаписываются на машинно-зависимые (в зависимости от архитектуры и ОС), после чего над SSA снова выполняются оптимизации, удаляется мертвый код, распределяются регистры, размечается стековый фрейм; после — ассемблер превращает всё это добро в машинный код и записывает объектный файл
# Статическая компиляция/линковка
Линковка (ну или компоновка) последний этап сборки. Статически слинкованный исполняемый файл не зависит от наличия других библиотек в системе во время своей работы.

Для включения статической компиляции/линковки (при этом все внешние библиотеки, от которых зависит исполнение кода будут встроены в итоговый бинарный файл) необходимо использовать переменную окружения при сборке `CGO_ENABLED=0` (т.е. `CGO_ENABLED=0 go build ...`). Полученный бинарный файл можно безбоязненно использовать, например, в docker-образе, основанном на `scratch` (т.е. не содержащем абсолютно никаких файлов, кристально чистая файловая система).

Однако, это накладывает некоторые ограничения и привносит особенности, которые необходимо помнить:
- `C`-код будет недоступен, совсем (часть модулей из stdlib Go от него зависят, к слову, но не критичных)
- Не будет использоваться **системный** DNS-резольвер
- Не будет работать проверка `x.509` сертификатов, которая должна работать на MacOS X

И ещё, если итоговый бинарный файл планируется использовать в docker `scratch`, то так же следует иметь в виду:
- Для осуществления HTTP запросов по протоколу HTTPS вашим приложением, в образ нужно будет поместить корневые SSL/TLS сертификаты `/etc/ssl/certs`
- Файл временной зоны (`/etc/timezone`) тоже будет необходим, чтоб корректно работать с датой/временем
# Директивы компилятора
Компилятор Go понимает некоторые директивы (пишутся они в виде комментариев, как правило `//go:directive`), которые влияют на процесс компиляции (оптимизации, проверок, и т.д.) но не являются частью языка.

Некоторые:
- `//go:linkname` – Указывает компилятору реальное местонахождение функции или переменной. Можно использовать **для вызова приватных функций** из других пакетов.
- `//go:nosplit` – Указывается при объявлении функции, и указывает на то, что вызов функции должен пропускать все обычные проверки на переполнение стека.
- `//go:norace` – Так же указывается при объявлении функции и "выключает" детектор гонки ([[Состояние гонки|race detector]]) для неё.
- `//go:noinline` – Отключает оптимизацию "инлайнига" для функции. Обычно используется отладки компилятора, escape-аналитики или бенчаркинга.
- `//go:noescape` – Тоже "функциональная" директива, смысл которой сводится к тому, что "я доверяю этой функции, и ни один указатель, переданных в качестве аргументов (или возвращенных) этой функции не должен быть помещен в кучу (heap)".
-  `//go:build` – Эта директива обеспечивает условную сборку. То есть мы можем "размечать" тегами файлы, и таким образом компилировать только определенные их "наборы" (тегов может быть несколько, а так же можно использовать `!` для указания "не"). Часто используется для кодогенерации, указывая какой-то специфичный тег (например `ignore` — `//go:build ignore`) чтоб файл никогда не участвовал в сборке итогового приложения.
- `//go:generate` – Позволяет указать какие **внешние** команды должны вызваться при запуске `go generate`. Таким образом, мы можем использовать кодогенерацию, к примеру, или выполнять какие-то операции что дожны предшевствовать сборке (например — `//go:generate go run gen.go`где `gen.go` это файл, что содержит `//go:build ignore` т.е. исключён из компиляции, но при этом генерирует для нас какие-то полезные данные и/или целые `.go` файлы).
- `//go:embed` – Позволяет "встраивать" внешние файлы в Go приложение. Требует импортирования пакета `embed` (`import _ "embed"`). Поддерживает типы `string`, `[]byte` и `embed.FS`.