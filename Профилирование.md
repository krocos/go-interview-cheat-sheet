Для профилирования "родными" средствами в поставке с Go имеется пакет `pprof` и одноименная консольная утилита `go tool pprof`. Причинами необходимости в профилировании могут стать:
- Длительная работа различных частей программы
- Высокое потребление памяти
- Высокое потребление ресурсов процессора

Профилировщик является **семплирующим** — с какой-то периодичностью мы прерываем работу программы, берем стек-трейс, записываем его куда-то, а в конце, на основе того, как часто в стек-трейсах встречаются разные функции, мы понимаем, какие из них использовали больше ресурсов процессора, а какие меньше.

Работа с ним состоит из двух этапов — сбор статистики по работе сервиса, и её визуализация + анализ. Собирать статистику можно добавив вызовы функций из пакета `pprof`, либо запустив HTTP сервер.
# Как работаете профилировщик?
Go runtime просит ОС посылать сигнал (`man setitimer`) с определенной периодичностью и назначает на этот сигнал обработчик. Обработчик берет стек-трейс всех горутин, какую-то дополнительную информацию, записывает ее в буфер и выходит.

Каковы же недостатки данного подхода?
- Каждый сигнал — это изменение контекста, вещь довольно затратная в наше время. В Go сейчас получается получить порядка 100 в секунду. Иногда этого мало
- Для нестандартных сборок, например, с использованием `-buildmode=c-archive` или `-buildmode=c-shared`, профайлер работать по умолчанию не будет. Это связано с тем, что сигнал `SIGPROF` (который посылает ОС) придет в основной поток программы, который не контролируется Go
- Процесс `user space`, которым является программа на Go, не может получить ядерный стек-трейс. Неоптимальности и проблемы иногда кроются и в ядре

Основное преимущество, конечно, в том, что Go runtime обладает полной информацией о своем внутреннем устройстве. Внешние средства, например, по умолчанию ничего не знают о горутинах. Для них существуют только процессы и треды.
