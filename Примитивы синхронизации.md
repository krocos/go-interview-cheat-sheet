# `sync.Mutex` и `sync.RWMutex`
Обеспечивают безопасный доступ к общим ресурсам.

Перед тем как войти в защищённую секцию надо захватить мютекс (`Lock`), а после отпустить (`Unlock`).

Под капотом используются `atomic`(`atomic.CompareAndSwapInt32` и `atomic.AddInt32`).

RW мютекс можно захватывать на чтение несколько раз, но 1 раз на запись.
# `synс.Map`
Предоставляет атомарный доступ к элементам `map`.

Из обычной [[Карты|карты]] могут читать тысячи горутин одновременно, но вот писать в нее – уже проблема.

Для обеспечения потоко-безопасного доступа к `map` можно использовать `sync.RWMutex`, но он имеет проблему производительности при работе на большом количестве ядер процессора (в `RWMutex` при блокировке на чтение каждая горутина должна обновить поле `readerCount`— простой счётчик, с помощью `atomic.AddInt32()`, что проиводит к сбросу кэша для этого адреса памяти для всех ядер, и каждое ядро становится в очередь и ждёт этот сброс и вычитывание из кэша — эта проблема называется **cache contention**).

`sync.Map` решает совершенно конкретную проблему **cache contention** в стандартной библиотеке для таких случаев, когда ключи в map стабильны (не обновляются часто) и происходит намного больше чтений, чем записей.
# `sync.WaitGroup`
Используется для координации в случае, когда программе приходится ждать окончания работы нескольких горутин.
# `sync.Cond`
Условная переменная (**CONDition variable**) полезна, например, если мы хотим разблокировать сразу несколько горутин (`Broadcast`), что не получится сделать с помощью канала. Метод `Signal` отправляет сообщение самой долго-ожидающей горутине.
# `sync.Once`
Позволяет определить задачу для однократного выполнения за всё время работы программы. Содержит одну-единственную функцию `Do`, позволяющую передавать другую функцию для однократного применения.
# `sync.Pool`
Это потокобезопасный пул объектов в Go, предназначенный для кэширования и повторного использования временных объектов, чтобы уменьшить нагрузку на сборщик мусора.
```go
import (
	"bytes"
	"sync"
)

var bufferPool = sync.Pool{
	New: func() interface{} {
		return new(bytes.Buffer)
	},
}

func main() {
	// Получаем буфер из пула
	buf := bufferPool.Get().(*bytes.Buffer)
	
	// Используем буфер
	buf.WriteString("hello")
	
	// Очищаем и возвращаем в пул
	buf.Reset()
	bufferPool.Put(buf)
}
```
## Когда использовать
1. Когда создание объектов дорого (например, большие буферы)
2. Когда объекты часто создаются и удаляются
3. Когда объекты можно безопасно повторно использовать
## Важные нюансы
- Объекты в пуле могут быть удалены в любой момент
- Не стоит хранить в пуле объекты с состоянием, которое может измениться
- Размер пула автоматически масштабируется под нагрузку