На собеседовании на позицию Go-разработчика, говоря о **Coupling (связность)** и **Cohesion (сплочённость)**, важно сделать акцент на их важности в проектировании чистого, поддерживаемого и масштабируемого кода.  
![[Pasted image 20250511151114.png]]
# Coupling (Связность)  
**Определение**: Мера зависимости между модулями (пакетами, структурами, функциями).  

**Типы связности в Go**:  
- **Жёсткая связность (Tight Coupling)**:  
  - Один модуль сильно зависит от внутренней реализации другого.  
  - Пример: Прямое использование структур другого пакета, а не интерфейсов.  
  - Проблемы: Усложняет тестирование, рефакторинг и переиспользование кода.  

- **Слабая связность (Loose Coupling)**:  
  - Модули зависят от абстракций (интерфейсов), а не от конкретных реализаций.  
  - Пример: Внедрение зависимостей через `interface` (Dependency Injection).  
  - Преимущества: Гибкость, лёгкость тестирования (можно подменить моки).  

**Как добиться слабой связности в Go?**  
- Использовать **интерфейсы** (`io.Reader`, `io.Writer` вместо конкретных типов).  
- Применять **Dependency Injection** (передавать зависимости извне, а не создавать внутри).  
- Избегать **глобального состояния** (пакетные переменные, `init()`).  
- Разделять код на **независимые пакеты** (микросервисная архитектура или чёткие слои).  

---  

# Cohesion (сплочённость)  
**Определение**: Мера того, насколько элементы модуля (функции, методы, структуры) связаны между собой по смыслу.  

**Типы сплочённости в Go**:  
- **Высокая сплочённость (High Cohesion)**:  
  - Все элементы модуля работают для одной цели.  
  - Пример: Пакет `json` в Go занимается только JSON-сериализацией.  
  - Преимущества: Лучшая читаемость, проще поддерживать и тестировать.  

- **Низкая сплочённость (Low Cohesion)**:  
  - Модуль делает слишком много несвязанных вещей.  
  - Пример: Пакет `utils` с кучей разнородных функций.  
  - Проблемы: Сложно понять, где что лежит, трудно рефакторить.  

**Как добиться высокой сплочённости в Go?**  
- Дробить большие пакеты на **маленькие, специализированные**.  
- Группировать **логически связанные** функции и структуры.  
- Избегать **"божественных объектов"** (типов, которые делают всё).  
- Следовать **[[SOLID]]** (особенно [[SOLID#Single responsibility principle|Single Responsibility Principle]]).  
# Примеры из Go  
- **Высокая сплочённость**:  
  ```go
  type UserRepository interface {
      GetByID(id int) (*User, error)
      Save(user *User) error
  }
  ```
  Все методы относятся к работе с пользователями.  

- **Слабая связность**:  
  ```go
  func ProcessData(r io.Reader, w io.Writer) error { ... }
  ```
  Функция работает с абстракциями `io.Reader/Writer`, а не с конкретными файлами или сетью.  
# Вывод для собеседования  
- **Хороший код на Go** стремится к **слабой связности и высокой сплочённости**.  
- Это делает код **тестируемым, переиспользуемым и легко изменяемым**.  
- В Go это достигается через **интерфейсы, [[SOLID#Dependency inversion principle|DI]], разделение пакетов и [[SOLID#Single responsibility principle|SRP]]**.  

Если попросят пример из вашего опыта — расскажите, как вы применяли эти принципы в реальных проектах (например, рефакторинг "жирного" пакета или переход на интерфейсы для мокирования в тестах).