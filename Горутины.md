Горутина (goroutine) — это функция, выполняющаяся конкурентно с другими горутинами в том же адресном пространстве.

Для её запуска достаточно использовать ключевое слово `go` перед именем вызываемой (или анонимной) функции.

Горутины очень легковесны (~**2,6Kb** на горутину). Практически все расходы — это создание стека, который очень невелик, хотя при необходимости может расти. Область их применения чаще всего следующая:
- Когда нужна асинхронность _(например когда мы работаем с сетью, диском, базой данных, защищенным мьютексом ресурсом и т.п.)_
- Когда время выполнения функции достаточно велико и можно получить выигрыш, нагрузив другие ядра

Сама структура горутины занимает порядка 600 байт, но для неё ещё выделяется и её собственный стек, минимальный размер котого составляет 2Kb, который увеличивается и уменьшается по мере необходимости _(максимум зависит от архитектуры и составляет 1 ГБ для 64-разрядных систем и 250 МБ для 32-разрядных систем)_.

Переключение между двумя Горутинами — супер дешевое, `O(1)`, то есть, не зависит от количества созданных горутин в системе. Всё, что нужно сделать для переключения, это поменять 3 регистра — `Program counter`, `Stack Pointer` и `DX`.
# В чем отличия горутин от потоков ОС?
- Каждый поток операционной системы имеет блок памяти фиксированного размера (зачастую до **2 Мбайт**) для стека — рабочей области, в которой он хранит локальные переменные вызовов функций, находящиеся в работе или приостановленные на время вызова другой функции. В противоположность этому go-подпрограмма начинает работу с небольшим стеком, обычно около **2 Кбайт**. Стек горутины, подобно стеку потока операционной системы, хранит локальные переменные активных и приостановленных функций, но, в отличие от потоков операционной системы, не является фиксированным; при необходимости он может расти и уменьшаться
- Потоки операционной системы планируются в ее ядре, а у go есть [[Планировщик горутин|собственный планировщик]] (m:n) мультиплексирующий (раскидывающий) горутинки (m) по потокам (n). Основной плюс — отсутствие оверхеда на переключение контекста
- Планировщик Go использует параметр с именем `GOMAXPROCS` для определения, сколько потоков операционной системы могут одновременно активно выполнять код Go. Его значение по умолчанию равно **количеству процессоров (ядер) компьютера**, так что на машине с 8 процессорами (ядрами) планировщик будет планировать код Go для выполнения на 8 потоках одновременно. Спящие или заблокированные в процессе коммуникации go-подпрограммы потоков для себя не требуют. Go-подпрограммы, заблокированные в операции ввода-вывода или в других системных вызовах, или при вызове функций, не являющихся функциями Go, нуждаются в потоке операционной системы, но GOMAXPROCS их не учитывает
- В большинстве операционных систем и языков программирования, поддерживающих многопоточность, текущий поток имеет идентификацию, которая может быть легко получена как обычное значение (обычно — целое число или указатель). У горутин нет идентификации, доступной программисту. Так решено во время проектирования языка, поскольку локальной памятью потока программисты злоупотребляют
# Аллокация памяти для горутин
Так как горутины являются **stackful** — то и память для них (их состояние) хранится на стеке. Поэтому, теоретически, если очень постараться и сделать миллиард вложенных вызовов, то можно сделать себе переполнение стека.

Для самих же переменных, что используются внутри горутин память берётся с хипа (ограничены только размером "физического" хипа, т.е. объемом памяти сколько есть на машине).
# Завершение горутин
Работу одной гороутины в принципе нельзя принудительно остановить из другой. Механизмы их завершения необходимо реализовывать отдельно (учить сами горутины завершаться).

Наиболее часто используются 2 подхода:
- это использование контекста `context.Context`
- и отдельного канала для уведомлений о необходимости завершения (часто для уведомлений используется пустая структура `struct{}`, которая ничего не весит)

